---
tags: メソッド, ApacheFlink, ストリーム処理, ステートフルコンピューティング, 耐障害性
aliases: Flink State Management
---

# メソッド: Flink 状態管理 (State Management)

## 概要
Flinkの状態管理は、[[メソッド/Apache_Flink]]が[[モデル/ステートフルコンピューティング]]を実現するためのコア機能です。ストリーム処理オペレータが計算の途中結果や過去のイベント情報を「状態」として保持し、[[メソッド/Flink_チェックポイント]]を通じて耐障害性を確保する仕組みを提供します。

## 前提となるモデル/理論(L1)とコンテキスト
* **L1モデル:** [[モデル/ステートフルコンピューティング]], [[モデル/ストリーム処理(データ)]], [[モデル/分散ストリーム処理アーキテクチャ(Flink)]]
* **コンテキスト:**
    * **目的:** ストリーム処理において、過去のデータや計算結果に基づいて現在の処理を行いたい（例: カウント、集計、パターン検出）。サーバー障害が発生しても、処理途中の状態を失わずに計算を継続したい。
    * **状況:** 個々のイベントだけでなく、イベント間の関連性や時間的な文脈が重要な処理。耐障害性と結果の正確性（Exactly-Once/At-Least-Once）が求められる。

## 具体的な手順・考慮事項
1.  **状態の種類 (Managed State):** Flinkが管理し、チェックポイントの対象となる状態。開発者はFlinkのAPIを通じて利用します。
    * **Keyed State:** `keyBy()`で分割されたキーストリームごとに管理される状態。同じキーを持つイベントは必ず同じタスクインスタンスで処理され、そのタスクがキーに対応する状態を保持します。
        * `ValueState<T>`: 単一の値を保持。
        * `ListState<T>`: 値のリストを保持。
        * `MapState<K, V>`: Key-Valueマップを保持。
        * `AggregatingState<IN, OUT>`: 入力を集約して単一の結果を保持。
        * `ReducingState<T>`: `AggregatingState`の特殊なケースで、同じ型の値を結合して単一の値を保持。
    * **Operator State:** 特定のキーに紐付かない状態。オペレータの各並列インスタンスがそれぞれ状態の一部を管理します。主にSource/Sinkコネクタで利用されます（例: Kafkaコンシューマのオフセット管理）。`CheckpointedFunction`インターフェースなどを通じてアクセスします。
2.  **状態へのアクセス:** 主に`RichFunction`（例: `RichMapFunction`）や`ProcessFunction`のサブクラス内で、`RuntimeContext`を通じて状態オブジェクトを取得し、`value()`, `add()`, `get()`, `put()`などのメソッドで読み書きします。
3.  **状態バックエンド (State Backend):** 状態を物理的にどこに、どのように保存するかを決定します。
    * `HashMapStateBackend`: Javaヒープメモリ上に状態を保持。高速だがメモリ容量に制限される。チェックポイントは永続ストレージへ非同期に書き出す。
    * `RocksDBStateBackend`: ディスク上の組込みKey-ValueストアRocksDBに状態を保持。メモリ容量を超える大きな状態を扱える。チェックポイントは永続ストレージへ書き出す（インクリメンタルチェックポイントが可能）。
4.  **状態の永続化と耐障害性:** [[メソッド/Flink_チェックポイント]]機構により、Managed Stateは定期的に永続ストレージ（HDFS, S3など）にスナップショットが保存され、障害からの復旧時に利用されます。
5.  **考慮事項:**
    * **状態のスコープ:** Keyed StateかOperator Stateかを適切に選択する。
    * **状態バックエンドの選択:** 状態サイズ、アクセス速度、耐障害性の要件に基づいて選択する。
    * **状態のクリア:** 不要になった状態は明示的にクリア (`clear()`) しないと残り続けるため、メモリリークやパフォーマンス低下の原因になりうる。State TTL (Time-to-Live) 機能で自動クリアも可能。
    * **パフォーマンス:** 状態アクセスはパフォーマンスに影響するため、アクセスパターンやデータ構造を考慮する。