---
tags: メソッド, ソフトウェアアーキテクチャ, 進化するアーキテクチャ, リファクタリング, マイグレーション
aliases: Incremental Change, Evolutionary Change
---

# 概要
漸進的な変更とは、[[モデル/進化するアーキテクチャ]]を実現するためのアプローチの一つで、大規模な一括変更（ビッグバンリライト）を避け、ソフトウェアアーキテクチャやシステム全体に対して、小さく、段階的、かつ継続的に変更を加えていく方法。

# 前提となるモデル/理論(L1)とコンテキスト
* **前提モデル/理論:** [[モデル/進化するアーキテクチャ]], [[モデル/変更容易性]], [[モデル/技術的負債]], [[モデル/アーキテクチャトレードオフ]]
* **コンテキスト:**
    * 既存のレガシーシステムをモダナイズしたい場合。
    * [[モデル/アーキテクチャスタイル]]を変更したいが、大規模な停止やリスクを避けたい場合（例：モノリスから[[モデル/マイクロサービスアーキテクチャ]]への移行）。
    * 継続的に[[モデル/技術的負債]]を返済し、システムの健全性を維持したい場合。
    * アジャイル開発プロセスの中で、アーキテクチャの改善も継続的に行いたい場合。
    * [[メソッド/フィットネス関数]]などを用いて、変更による影響を監視しながら進めたい場合。

# 具体的な手順・考慮事項
1.  **目標アーキテクチャの定義:** 将来的に目指すアーキテクチャの姿や改善したい[[モデル/アーキテクチャ特性]]を明確にする。
2.  **変更単位の特定:** システム全体を一気に変更するのではなく、比較的小さく、独立して変更可能な部分（[[モデル/コンポーネント]]、機能、[[モデル/アーキテクチャ量子]]）を特定する。
3.  **変更戦略の選択:** 状況に応じて適切な戦略を選択する。例：
    * **Strangler Fig パターン:** 既存システムの特定機能を新しい実装に置き換え、徐々に古いシステムを「絞め殺して」いく。リバースプロキシなどを利用してリクエストを振り分ける。
    * **並行稼働（Parallel Run）:** 新旧システムを並行して稼働させ、結果を比較しながら段階的に移行する。
    * **機能単位での段階的リリース:** 新しいアーキテクチャに基づいた機能を少しずつリリースしていく。
    * **抽象化レイヤーの導入:** 既存システムと新しい実装の間に抽象化レイヤーを設け、依存関係を減らしながら移行を進める。
4.  **安全な変更のための準備:**
    * **[[メソッド/フィットネス関数]]** を定義し、変更によって既存機能や[[モデル/アーキテクチャ特性]]が悪化しないことを継続的に検証する。
    * **十分な自動テスト**を用意し、リグレッション（変更による既存機能の破壊）を防ぐ。
    * **可観測性（Observability）** を確保し、変更後のシステムの動作を監視する。
    * **ロールバック計画**を用意する。
5.  **変更の実施と検証:** 小さな単位で変更を加え、テストと監視を通じて安全性を確認しながら段階的に進める。
6.  **繰り返し:** 目標アーキテクチャに到達するまで、または継続的な改善プロセスとして、上記のステップを繰り返す。

**利点:**
* **リスクの低減:** 一度の変更範囲が小さいため、問題が発生した場合の影響範囲が限定され、ロールバックも比較的容易。
* **継続的な価値提供:** 開発を長期間停止することなく、改善を進めながら新しい価値を提供し続けられる。
* **学習とフィードバック:** 段階的に進める中で得られた学びやフィードバックを、次のステップに活かすことができる。
* **心理的負担の軽減:** 大規模な一括変更に比べて、チームの心理的なプレッシャーが少ない。

**注意点:**
* 移行期間中は新旧の仕組みが混在し、一時的に**複雑性が増す**可能性がある。
* 全体像を見失わず、**一貫性を保ちながら**進めるための計画と管理が必要。
* 適切な**変更単位の見極め**が重要。