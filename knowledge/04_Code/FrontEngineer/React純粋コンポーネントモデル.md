# React純粋コンポーネントモデル (React Pure Component Model)

## モデル概要
本モデルは、Reactコンポーネントの「純粋性」について、その定義、重要性、および実践的な側面を体系化したものである。Reactのコンポーネントは、関数型プログラミングにおける純粋関数と同様に、同じ入力に対して常に同じ出力を返す「純粋」であるべきだとされる。これにより、コードの予測可能性、保守性、そしてReactの高度な最適化機能（例: React Compilerによる自動的なメモ化や不要な再レンダーのスキップなど）の恩恵を最大限に享受することを目的とする。副作用の定義、JSX式の「同じ」の意味、副作用を書いて良い場所と悪い場所、そしてフックと純粋性の関係に焦点を当てる。

## モデル適用条件
- Reactアプリケーションを開発しており、コンポーネントの品質とパフォーマンスを向上させたい場合。
- Reactのレンダープロセスやフックの挙動について、より深い理解を求めている場合。
- コンポーネントの予期せぬ再レンダリングやバグに悩まされており、その原因を特定したい場合。
- Reactの新しい機能（Suspense, Concurrent Rendering, React Compilerなど）を効果的に活用したい場合。

## モデル構造
本モデルは、Reactコンポーネントの純粋性を構成する主要な要素（コンポーネント）から成り立っている。

1.  **純粋性の定義 (Definition of Purity)**
    -   **自分の仕事に集中する**: 呼び出される前に存在していたオブジェクトや変数を変更しない（副作用を含まない）。
    -   **同じ入力には同じ出力**: 同じ入力を与えると、常に同じ結果を返す（参照透過性を持つ）。
    -   **Reactの文脈での純粋性**: Reactは、全てのコンポーネントが純関数であると仮定して設計されている。コンポーネントはJSXを返すだけであり、レンダー前に存在していたオブジェクトや変数を書き換えない。

2.  **副作用の例と許容される場所 (Examples of Side Effects & Permitted Locations)**
    -   **禁止される副作用**: コンポーネントの外部への書き込み（例: グローバル変数の変更）、外部からの読み取り（例: localStorageからの読み取りなど、非決定性や外部依存を生むもの）、同じ入力で結果が変わる（例: Math.random()の使用）、ネットワークリクエストの直接実行。
    -   **許容される場所**: イベントハンドラの中には副作用を書いても良い。これは、イベントハンドラがコンポーネントの「返り値の計算」に含まれないため。useEffectの中も同様に副作用を記述できる。

3.  **「同じ」の意味 (Meaning of "Same")**
    -   **JSX式の同一性**: Reactコンポーネントの返り値であるJSX式が「同じ」であるとは、JavaScriptの `===` 演算子での比較ではなく、「意味が同じ」であることを指す。JSX式はReactランタイムへの「指示書」であり、同じ指示を意味するJSX式を返せば純粋である。
    -   **最適化のための「真の同一性」**: `useMemo` や `useCallback` は、Reactランタイムが再レンダリングを判断する際に、オブジェクトが本当に（`===` の意味で）同じであるかを助けるために使われる。React Compilerはこれを自動化する。

4.  **フックと純粋性 (Hooks & Purity)**
    -   **フックの返り値も入力**: `useState` などのフックの呼び出しは、関数型プログラミングの一般論では副作用と見なされがちだが、Reactの文脈ではフックの返り値もコンポーネントに対する入力として扱う。これにより、フックを使用してもコンポーネントは純粋であると見なされる。
    -   **コンポーネントの記憶領域**: フックはコンポーネントの記憶領域を提供し、そのスナップショットがコンポーネントの入力の一部となる。
    -   **フック内の副作用**: `useMemo` のコールバック内には副作用を書いてはいけない（返り値の計算の一部のため）。`useEffect` のコールバック内には副作用を書いても良い（返り値の計算に含まれないため）。

## モデル法則
- **法則1: 純粋なコンポーネントは予測可能で、テストしやすい。**
  -   同じ入力に対して常に同じ出力を返すため、コンポーネントの振る舞いを容易に予測でき、単体テストも容易になる。
- **法則2: 副作用はコンポーネントのレンダリングロジックから分離すべきである。**
  -   コンポーネントの返り値の計算に副作用を含めないことで、Reactのレンダープロセスが純粋に保たれ、予期せぬバグや挙動を防ぐことができる。
- **法則3: Reactの「純粋性」は、その内部動作と最適化の前提である。**
  -   Reactはコンポーネントが純粋であることを前提に、Suspense、Concurrent Rendering、React Compilerといった高度な機能を設計・提供している。
- **法則4: フックは純粋性を損なうものではなく、むしろ純粋なコンポーネントを記述するためのツールである。**
  -   フックの返り値をコンポーネントの入力の一部と見なすことで、状態を持つコンポーネントも純粋性の原則に則って記述できる。フックは状態管理やライフサイクル処理を純粋なコンポーネントの枠組みに統合する。

## 実装ガイドライン
1.  **コンポーネントの返り値の計算に副作用を含めない:**
    -   コンポーネントの関数本体内で、DOMの直接操作、外部変数の変更、ネットワークリクエストなどを直接行わない。
2.  **イベントハンドラやuseEffectで副作用を扱う:**
    -   ユーザーインタラクションやライフサイクルイベントに伴う副作用は、イベントハンドラや `useEffect` フックの内部で記述する。
3.  **`useMemo` や `useCallback` を適切に活用する:**
    -   パフォーマンス最適化のために、計算結果や関数オブジェクトの参照同一性を保つ必要がある場合に、これらのフックを適切に使用する。
4.  **フックのルールに従う:**
    -   フックはコンポーネントのトップレベルで呼び出す、ループや条件分岐の中では呼び出さないなど、Reactのフックのルールを厳守する。
5.  **テストを通じて純粋性を確認する:**
    -   コンポーネントのテストにおいて、同じpropsを与えた場合に常に同じJSXが返されることを確認する。
6.  **React Compilerの導入を検討する:**
    -   将来的に、`useMemo` や `useCallback` の手動での記述を減らし、コンポーネントの純粋性を自動的に最適化するために、React Compilerの導入を検討する。

## モデル限界と注意点
- Reactの純粋性の概念は、関数型プログラミングの一般論とは異なる独自の解釈を含むため、理解に混乱が生じる場合がある。Reactの文脈での「純粋性」の定義を明確に理解することが重要である。
- パフォーマンス最適化のための `useMemo` や `useCallback` の乱用は、かえってコードの複雑性を増し、パフォーマンスを悪化させる可能性がある。必要性を理解した上で適切に使用する。
- 例外処理は純粋性を損なうものではないが、レンダリング中に例外を発生させることは、アプリケーションの安定性に影響を与える可能性があるため、Error Boundaryなどを適切に利用してハンドリングする。

## 関連事例

### 実装事例
- [Reactコンポーネントが「純粋である」とはどういうことか？　丁寧な解説](https://zenn.dev/uhyo/articles/react-pure-components)
  -   本モデルの原典である記事。Reactコンポーネントの純粋性について、副作用の定義、JSX式の「同じ」の意味、副作用を書いて良い場所と悪い場所、そしてフックと純粋性の関係が詳細かつ丁寧に解説されている。
  -   **学習ポイント**: Reactコンポーネントの純粋性を理解することは、Reactの内部動作を深く理解し、より堅牢でパフォーマンスの高いアプリケーションを開発するための基礎となる。

### 関連モデル
- [関数型プログラミングの原則](https://en.wikipedia.org/wiki/Functional_programming) - Reactの純粋性の概念は、関数型プログラミングの純粋関数に由来する。この原則を理解することで、Reactコンポーネントの設計思想をより深く理解できる。
- [コンポーネント設計パターン](https://react.dev/learn/thinking-in-react) - 純粋なコンポーネントを効果的に組み合わせ、再利用性の高いUIを構築するための設計パターンを学ぶ上で関連する。
