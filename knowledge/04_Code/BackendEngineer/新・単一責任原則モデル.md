# 新・単一責任原則モデル (New Single Responsibility Principle Model)

## モデル概要
本モデルは、ソフトウェア設計における「新・単一責任原則」を体系化したものである。従来の単一責任原則を「単一の抽象度」と「単一の文脈」という概念で再定義し、設計のバグが顕在化する前に、設計段階でのレビューや議論を通じて理論的に検出・回避することを目的とする。抽象化に関する原則、文脈に関する原則、命名に関する原則の3つの側面から、モジュール設計の品質を高め、変更容易性を向上させるための具体的な指針を提供する。特に、共通化の罠や、単一責任原則が破られるパターンを詳細に分析する。

## モデル適用条件
- ソフトウェアの設計・開発において、モジュール分割や共通化の判断に迷う場合。
- コードベースの複雑性が増大し、変更容易性や保守性が低下していると感じる場合。
- 設計レビューやリファクタリングの際に、客観的な評価基準を求めている場合。
- ソフトウェアアーキテクトやリードエンジニアが、チームの設計品質を向上させたい場合。

## モデル構造
本モデルは、新・単一責任原則を構成する主要な要素（コンポーネント）から成り立っている。

1.  **新・単一責任原則の定義 (Definition of New Single Responsibility Principle)**
    -   **単一の抽象度**: 設計上の単位は、単一の抽象度を持つべきである。モジュールがその責任範囲内で完結し、不必要な詳細を知らない状態（これ以上分離できないという意味で、モジュールが「知りすぎている」状態を避ける）。
    -   **単一の文脈**: 設計上の単位は、単一の文脈を持つべきである。特定のモジュールの直下で呼ばれるべきものが、不適切な場所から呼ばれることを避ける。

2.  **抽象化に関する原則 (Principles of Abstraction)**
    -   **原則1**: 文脈を保つ・保たないにかかわらず、抽象化ができる場合は抽象化をしなければならない（変更容易性や再利用性を高め、認知負荷を減らすため）。モジュールから内部の処理内容を知らなくても良い部分を取り出し、分かりやすい役割の名前を与えて分離する。
    -   **原則2**: 上位モジュール・下位モジュールともに抽象化を破壊してはならない。不適切な分割や、本来隠すべき処理を無理やり突破するパターン（例: 親モジュールが子モジュールの内部詳細に依存する）を避ける。

3.  **文脈に関する原則 (Principles of Context)**
    -   **原則1**: 文脈依存性があるモジュールを指定された文脈の直下以外で呼び出してはならない。複数の呼び出し元ごとの文脈情報が1つのモジュールに含まれることで、モジュールの複雑性が高まることを防ぐ。
    -   **原則2**: 文脈依存性がないモジュールを不適切な文脈で呼び出してはならない。モジュールが想定していない範囲での再利用が設計上の問題を引き起こすことを防ぐ。

4.  **命名に関する原則 (Principles of Naming)**
    -   **原則1**: モジュールは名前から推測できない処理を行ってはならない。モジュールの挙動と名前が一致していることを保証する。
    -   **原則2**: 名前は、グループの名前、ディレクトリ構成と合わせて文脈を完全に指定しなければならない。モジュールの配置や命名が、その設計意図を明確に伝えるようにする。
    -   **原則3**: 名前は、モジュールの文脈の範囲で最も抽象的でなければならない。個々のモジュールの認知負荷を下げ、上位モジュールが処理の意味や役割だけを理解して使えるようにする。

5.  **単一責任原則が破られるパターン (Patterns of SRP Violations)**
    -   **抽象度が複数だが文脈は単一**: モジュールが多くのことを知りすぎている状態。比較的修正が容易。
    -   **抽象度は単一だが文脈が複数**: モジュール自体は適切に抽象化されているが、複数のモジュールから呼ばれることで文脈が増えてしまう状態。共通処理をより文脈の少ないモジュールとして切り出すことで解決。
    -   **抽象度も文脈も複数**: 上記2つの誤りが同時に発生している状態。リファクタリングが非常に困難で、「作り直した方が速いクソコード」となる典型的なパターン。

## モデル法則
- **法則1: 設計の品質は、抽象度と文脈の単一性によって測られる。**
  -   モジュールが単一の抽象度と単一の文脈を持つことで、コードの理解しやすさ、変更容易性、再利用性が向上する。
- **法則2: 割れ窓理論は設計にも適用される。**
  -   抽象化に失敗している設計や、モジュールの設計意図と配置・命名の設計意図が異なる場合、プログラマの理解を困難にし、より破綻した設計を生み出す。
- **法則3: 共通化は諸刃の剣である。**
  -   安易な共通化は、モジュールに複数の文脈を持たせ、将来的な変更を困難にする「共通化の罠」を生み出す。真に共通化すべきは、文脈依存性のない抽象化された処理である。
- **法則4: 違反の度合いはリファクタリングの難易度に直結する。**
  -   単一責任原則への違反が弱い場合は修正が容易だが、強い違反はコードベース全体を再構築する必要があるほどのリファクタリングコストを発生させる。

## 実装ガイドライン
1.  **モジュールの抽象度と文脈を意識する:**
    -   新しいモジュールを設計する際、または既存のモジュールをリファクタリングする際に、そのモジュールが単一の抽象度と単一の文脈を持つように意識する。
2.  **抽象化に関する原則を適用する:**
    -   モジュールから内部の処理内容を知らなくても良い部分を積極的に切り出し、適切な名前を与える。上位・下位モジュールともに抽象化を破壊しないように注意する。
3.  **文脈に関する原則を適用する:**
    -   モジュールが特定の文脈に強く依存する場合は、その文脈の直下でのみ呼び出すように制限する。汎用的なモジュールは、文脈依存性のない形で設計する。
4.  **命名に関する原則を遵守する:**
    -   モジュールの名前は、その機能と文脈を正確に反映するようにする。グループ名やディレクトリ構成と合わせて、完全な文脈を伝えるようにする。
5.  **アクセシビリティ設定を適切に利用する:**
    -   `private`, `public` などの修飾子や `unexported`, `exported` といった言語機能を用いて、モジュールへのアクセス範囲を制限し、設計者の意図をコードで表現する。
6.  **設計トレーニングを実践する:**
    -   既存のソフトウェアのモジュールに対して、その抽象度と文脈をコメントとして記述する練習を行う。これにより、単一責任原則の違反を早期に発見する能力を養う。

## モデル限界と注意点
- 新・単一責任原則は理論的な概念であり、実践には経験と洞察が必要となる。特に、抽象度と文脈の「単一性」の判断は、状況によって解釈が分かれる場合がある。
- 既存の「クソコード」をこの原則に沿ってリファクタリングすることは、非常に困難な場合がある。場合によっては、作り直しを検討することも必要となる。
- 原則の適用は、常にトレードオフを伴う。例えば、過度な抽象化は、かえってコードの可読性を損なう可能性がある。

## 関連事例

### 実装事例
- [どうしてあなたの共通化は間違っているのか：第5章「新・単一責任原則」](https://qiita.com/wolfmagnate/items/2cc028913d33878200f3)
  -   本モデルの原典である記事。単一責任原則を「単一の抽象度」と「単一の文脈」で再定義し、抽象化、文脈、命名に関する原則、そして単一責任原則が破られるパターンを詳細に解説している。
  -   **学習ポイント**: ソフトウェア設計の品質を高めるためには、モジュールが単一の抽象度と単一の文脈を持つように設計し、共通化の罠を回避することが重要である。

### 関連モデル
- [オブジェクト指向設計原則 (SOLID)](https://en.wikipedia.org/wiki/SOLID) - 単一責任原則はSOLID原則の一つであり、本モデルはSRPをより深く理解するための具体的な指針を提供する。
- [ドメイン駆動設計 (Domain-Driven Design)](https://en.wikipedia.org/wiki/Domain-driven_design) - 文脈（Bounded Context）の概念は、DDDにおける重要な要素であり、本モデルの文脈に関する原則と深く関連する。
