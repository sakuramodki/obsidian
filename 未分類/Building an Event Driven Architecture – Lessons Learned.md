分類: #事例 #ブログ

# 関連情報
URL : https://amanagrawal.blog/2019/08/27/building-an-event-driven-architecture-lessons-learned/
# コンテキスト
とあるeコマース会社における[[Event Driven Architecture]]のアーキテクチャ設計

# 要約
この記事は、筆者とそのチームがeコマース企業の補充管理システムにおいて、イベント駆動型アーキテクチャ（EDA）を構築した際の経験と学びをまとめたものです。プロジェクトの目的は、在庫補充のための仕入発注に関する手作業を自動化することでした。

**EDAを選択した理由と設計:**

- 業務要件（「〜が起こったときに〜する」）がリアルタイム性とイベントへの反応を求めていたため、EDAが適していると判断されました。
- イベントソーシング(ES)やCQRSは、監査証跡や高スケール要件がなかったため、複雑さを考慮して採用しませんでした。（**教訓1: ES/CQRSで過剰設計しない**）
- バックエンドはドメインモデル中心に開発を開始し、インフラ（メッセージキュー等）の決定は後回しにしました。イベントの種類に応じて、Event Carried State TransferやChange Data Captureなどを組み合わせたハイブリッドアプローチを採用しました。
- フロントエンドはバックエンドと分離し、REST APIで連携。バックエンドの障害がUIに波及しないようにしました。（**教訓2: ドメイン中心でシンプルなアーキテクチャから始め、決定を記録する**）
- イベントの取得元は様々でしたが、Hexagonalアーキテクチャ（Ports and Adapters）を採用し、インフラ依存部分を分離することで、変化に対応しやすくしました。（**教訓3: 組織構造を理解し、Ports and Adapters等で変化に強い設計を**）

**耐障害性、競合、監視、テストに関する学び:**

- メッセージキューと冪等性（べきとうせい）のある処理により、耐障害性と回復性を確保しました。デッドレターキュー（DLQ）の管理戦略も重要です。（**教訓4: 耐障害性とパフォーマンス目標、DLQ管理を初期に考慮する**）
- イベントの非同期性から生じる競合状態（Race Condition）には、優先順位付け、処理の分離（例：削除を別プロセス化）、オプティミスティック同時実行制御などで対処しました。（**教訓5: 競合状態を予測し、一貫性を保つ設計を。重要な操作を優先する**）
- EDAのデバッグは困難なため、相関IDを用いた詳細なロギングと、主要メトリクスを監視するダッシュボード、実用的なアラートが不可欠です。（**教訓6: 優れたロギングとモニタリングはEDAに不可欠**）
- テストは、ドメインレベルの単体テストから始め、イベントハンドラーはスタブを用いてテストしました。DTO変換ロジックのテスト漏れに注意が必要です。LocalstackやDockerを用いたローカルでの統合テストも重要です。（**教訓7: 適切なスタブで振る舞いをテストし、ローカル統合テストを最低限実施する**）

筆者は、このシステムがまだ開発途上であり、学び続けているとしつつ、これらの7つの教訓がEDA構築を目指す他の開発者の参考になればと述べています。
