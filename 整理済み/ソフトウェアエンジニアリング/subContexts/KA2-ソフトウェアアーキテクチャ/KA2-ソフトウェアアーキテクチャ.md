#コンテキスト
# このカテゴリについて

> [!NOTE]
> このカテゴリがどのようなものか説明します。
> 可能な限りどのような課題を扱うかの対象を明確にします。

ここでは[ソフトウェアアーキテクチャの基礎](https://www.notion.so/1cc0d3b71e038033856fca41ac9eeb2b?pvs=21) を通してソフトウェアアーキテクチャの基本概念に触れます。
またソフトウェアアーキテクトという役割についても触れていきます。

## **1章 イントロダクション**

### **ソフトウェアアーキテクチャの定義**

本書は、ソフトウェアアーキテクチャを単一の定義に限定せず、以下の4つの主要な側面から構成されるものとして定義している。

1. **システムの構造 (Structure of the system):** ソフトウェアを構成する要素とそれらの関係性。
2. **アーキテクチャ特性 (Architecture characteristics):** システムがどのように振る舞うべきかを定義する品質特性（非機能要件、"-ilities"とも呼ばれる）。例：パフォーマンス、スケーラビリティ、セキュリティなど。
3. **アーキテクチャ決定 (Architecture decisions):** システムの構造と特性を実現するための設計上の制約や選択。
4. **設計原則 (Design principles):** アーキテクチャ決定を導くためのガイドラインやルール。

この多角的な定義は、アーキテクチャが単なる技術的な構成図以上のものであることを示唆している。それはソフトウェアシステムの成功に不可欠な土台であり **1**、ビジネス目標、チームのダイナミクス、そして継続的な進化と深く結びついた、社会技術的な（socio-technical）規律であるという認識が基盤にある。

### **アーキテクトに期待されること**

ソフトウェアアーキテクトの役割は多岐にわたる。本書では、アーキテクトに期待される主要な活動と能力を以下のように詳述している。

- **アーキテクチャ決定を行う:** 技術的制約の中で最適な選択を行う 。
- **アーキテクチャを継続的に分析する:** システムの健全性を維持し、改善点を見つける。
- **最新技術動向を把握する:** 新しい技術やプラクティスを学び続ける。
- **決定事項の遵守を徹底する:** チームがアーキテクチャ上の決定に従うように導く。
- **多様な分野への露出と経験:** 幅広い技術やドメインに触れる。
- **ビジネスドメイン知識を持つ:** ビジネス目標を理解し、技術的な決定に反映させる。
- **対人スキルを持つ:** 効果的なコミュニケーション、交渉、リーダーシップを発揮する。
- **組織内の力学を理解し、舵取りする:** プロジェクトを円滑に進めるための政治的な洞察力を持つ。

これらの期待事項は、アーキテクトには技術的な専門知識だけでなく、ビジネス、コミュニケーション、リーダーシップといった広範なスキルが求められることを明確に示している。特に、ビジネスドメイン知識、対人スキル、政治的な舵取り能力といった要素が含まれている点は、アーキテクチャが純粋な技術的問題解決にとどまらない活動であることを強調している **6**。

### **アーキテクチャと他の領域との交差点**

ソフトウェアアーキテクチャは孤立して存在するものではなく、ソフトウェア開発ライフサイクルの他の多くの側面と密接に関連している。

- **エンジニアリングプラクティス:** TDD、CI/CD、アジャイル開発手法などがアーキテクチャの設計と実装にどう影響するか。
- **オペレーション/DevOps:** デプロイメント、モニタリング、運用容易性などがアーキテクチャ特性としてどう考慮されるか。
- **プロセス:** 開発プロセス（例：ウォーターフォール、アジャイル）がアーキテクチャの決定や進化にどう関わるか。
- **データ:** データモデリング、データベース設計、データフローなどがアーキテクチャ全体とどう統合されるか。

これらの交差点を理解することは、アーキテクチャが開発、運用、データ、プロセスといった要素を結びつけ、調整する中心的な役割を担っていることを示している。アーキテクトは、これらの異なる領域間の相互作用を考慮し、システム全体の整合性を保つ必要がある。

### **ソフトウェアアーキテクチャの法則**

本書は、ソフトウェアアーキテクチャの実践を導くための基本的な考え方として、以下の2つの「法則」を提示している。

- **第一の法則: ソフトウェアアーキテクチャはトレードオフがすべてである。**
    - 完璧なアーキテクチャは存在せず、ある特性（例：パフォーマンス）を向上させようとすると、別の特性（例：開発の複雑さ）が犠牲になることが多い。アーキテクトの重要な役割は、これらのトレードオフを理解し、分析し、プロジェクトの文脈において最適なバランスを見つけることである。
- **第二の法則: 「どのように (how)」よりも「なぜ (why)」の方がずっと重要である。**
    - 特定の技術やパターンを選択した理由、つまりその決定の背後にある根拠や目的を理解し、文書化することが、その技術自体よりも重要である。これにより、将来の変更や保守が容易になり、アーキテクチャの一貫性が保たれる。

これらの法則は、本書全体を通じて繰り返し現れるテーマの基礎となる。特に第一の法則は、アーキテクチャ上のあらゆる決定が、何らかの利点と欠点の交換であることを常に意識させる。第二の法則は、アーキテクチャ決定の文書化（第19章）やコミュニケーション（第21章）の重要性を強調する根拠となる。これらの法則を早期に提示することで、読者は以降の章で紹介される概念（特性、パターンなど）を、絶対的な「正解」としてではなく、常にトレードオフと文脈依存の観点から評価するよう促される。

## **第2章 アーキテクチャ思考 (Architectural Thinking)**

### **アーキテクチャと設計の違い**

ソフトウェア開発において、「アーキテクチャ」と「設計」という言葉はしばしば混同されるが、本書では両者を区別することの重要性を説いている。一般的に、アーキテクチャはシステムの高レベルな構造、主要コンポーネントとその相互作用、そしてシステム全体に影響を与える重要な設計決定（特に変更が困難なもの）に関わる。かつては「後で変更するのが難しいもの」がアーキテクチャの定義として語られることもあったが、マイクロサービスのような変更を前提としたスタイルが登場したことで、この定義も変化している側面がある。一方、設計はより詳細なレベル、例えば個々のクラスやモジュール内部の実装に関わる。この区別は絶対的なものではなく境界は曖昧だが、アーキテクトはより抽象度が高く、システム全体への影響が大きい問題に焦点を当てる傾向がある。

### **技術的な幅**

効果的なアーキテクトであるためには、特定の技術に深く精通しているだけでなく、幅広い技術やソリューションに関する知識、すなわち「技術的な幅」を持つことが不可欠である。これにより、特定の問題に対して複数の選択肢を検討し、それぞれの技術が持つ利点、欠点、そしてトレードオフを客観的に評価することが可能になる。技術的な幅がなければ、慣れ親しんだ技術や偏った知識に基づいて不適切な決定を下してしまうリスクがある。

### **トレードオフの分析**

第一の法則「ソフトウェアアーキテクチャはトレードオフがすべてである」を実践するためには、トレードオフを効果的に分析し、調整（reconciling）する能力が中核となる。これは、単に選択肢の長所と短所をリストアップするだけでなく、それらがプロジェクトの特定の目標や制約（特にアーキテクチャ特性）にどのように影響するかを深く理解し、競合する要求事項の間でバランスの取れた妥協点を見出すプロセスである。この分析能力は、アーキテクトが下すほぼすべての決定の基礎となる。

### **ビジネスドライバーの理解**

優れたアーキテクチャは、技術的な要求だけでなく、ビジネスの目標や要求（ビジネスドライバー）を反映したものでなければならない。アーキテクトは、ビジネスが何を達成しようとしているのか（例：市場投入時間の短縮、運用コストの削減、新規市場への参入）を理解し、それを具体的なアーキテクチャ上の関心事（例：デプロイ容易性、スケーラビリティ、拡張性）に変換する役割を担う。この変換能力により、技術的な決定がビジネス価値に直接貢献することが保証される。

### **アーキテクチャと実践的なコーディングのバランス**

アーキテクトがどの程度実践的なコーディングに関与すべきかは、しばしば議論の的となる。本書では、アーキテクトがコーディングから完全に離れることのリスクと、関与し続けることの利点の両方を示唆している。コーディングに関与することで、アーキテクトはチームのボトルネックになることを避け、実践的な経験を積み、開発チームが直面する課題や開発環境をより深く理解できる。これは、開発チームとの信頼関係を築き、より現実的で実行可能なアーキテクチャを設計する上で役立つ。一方で、アーキテクトは高レベルな視点を維持し、戦略的な決定に時間を割く必要もあるため、適切なバランスを見つけることが重要となる。

この章で述べられている「アーキテクチャ思考」は、単なる技術スキルの集合ではなく、抽象化、統合、そしてシステム全体の特性や長期的な影響に焦点を当てる独特の思考様式として提示されている。技術的な幅、トレードオフ分析、ビジネスドライバーの理解といった要素はすべて、日常的な開発タスクよりも高い抽象度で、より広範な要因を考慮する思考プロセスを構成している。

## **第3章 モジュール性 (Modularity)**

### **定義**

モジュール性とは、システムを独立した交換可能な単位（モジュール）に分割する度合いを指す。適切にモジュール化されたシステムは、理解しやすく、変更しやすく、テストしやすく、再利用しやすいといった利点を持つ。モジュール性は、ソフトウェアアーキテクチャにおける基本的な品質特性の一つであり、多くのアーキテクチャ決定に影響を与える。

### **モジュール性の計測**

モジュール性は主観的な概念に留まらず、客観的な指標を用いて計測し、改善を図ることができる。本書では、モジュール性を評価するための主要なメトリクスを紹介している **6**。

- **凝集度 (Cohesion):** モジュール内の要素が、単一の明確な目的のためにどれだけ強く関連し合っているかを示す度合い 。凝集度が高いモジュールは、責務が明確で理解しやすい。
- **結合度 (Coupling):** あるモジュールが他のモジュールにどれだけ依存しているかを示す度合い 。結合度が低いほど、モジュール間の独立性が高く、変更の影響範囲が限定される。
- **コナーセンス (Connascence):** 結合度をより洗練させた概念で、「あるコンポーネントの変更が、システムの全体的な正しさを維持するために、別のコンポーネントの変更を必要とする場合、2つのコンポーネントはコナーセント（接続）されている」と定義される 。コナーセンスは、変更が連鎖する理由に着目し、より深いレベルでの依存関係を分析する。
    - **静的コナーセンス:** コンパイル時または静的解析で検出可能な依存関係。名前 (Connascence of Name)、型 (Connascence of Type)、意味 (Connascence of Meaning/Convention)、アルゴリズム (Connascence of Algorithm)、位置 (Connascence of Position) が含まれる 。
    - **動的コナーセンス:** 実行時にのみ明らかになる依存関係。実行順序 (Connascence of Execution)、タイミング (Connascence of Timing)、値 (Connascence of Value)、アイデンティティ (Connascence of Identity) が含まれる 。
    - コナーセンスには「強さ」があり、より強い（変更が波及しやすい）コナーセンスを、より弱い（影響が少ない）コナーセンスにリファクタリングすることで、システムの保守性を向上させることができる 。
- **抽象度 (Abstractness)、不安定度 (Instability)、主系列からの距離 (Distance from the Main Sequence):** Robert C. Martin氏によって提唱された、パッケージ間の依存関係の健全性を評価するためのメトリクス群 。抽象度が高い（インターフェースが多い）パッケージは安定的であるべき、不安定な（変更されやすい）パッケージは他の多くから依存されるべきではない、といった原則に基づき、パッケージ構造の改善点を特定するのに役立つ。

これらの具体的なメトリクスを導入することで、モジュール設計は曖昧な原則から測定可能なエンジニアリングプラクティスへと昇華する。これは、アーキテクチャに厳密性をもたらすという本書全体のテーマと合致しており、アーキテクトは直感だけでなく客観的なデータに基づいて構造を評価し、リファクタリングの必要性を判断できるようになる。特にコナーセンスは、なぜ変更が連鎖するのかという根本原因に迫るため、単純な依存関係の数え上げよりも深い洞察を提供し、より効果的な改善策を導き出す可能性がある。

### **モジュールからコンポーネントへ**

モジュールは主に論理的な設計単位を指すが、アーキテクチャにおいては、それらがどのように物理的なデプロイ単位や実行時単位、すなわち「コンポーネント」として実現されるかを考える必要がある。この概念的な橋渡しは、第8章のコンポーネントベース思考でさらに詳しく掘り下げられる。

## **第8章 コンポーネントベース思考 (Component-Based Thinking)**

### **コンポーネントの定義**

ソフトウェアコンポーネントとは、明確なインターフェースを持ち、特定の機能や責務を担う、独立してデプロイまたは交換可能なソフトウェアの単位である。本書では、コンポーネントの識別、結合度、凝集度、分割、粒度といった側面からコンポーネントについて議論する。

### **コンポーネント識別の流れ**

効果的なコンポーネントを識別するための、反復的なプロセスが推奨される。

1. **初期コンポーネントの識別:** ドメイン知識や初期要件に基づき、大まかなコンポーネント候補を洗い出す。
2. **要件の割り当て:** 特定された要件を各コンポーネント候補に割り当てる。
3. **役割と責務の分析:** 各コンポーネントが担うべき役割と責務を明確にする。
4. **アーキテクチャ特性の分析:** 第4章から第7章で定義・特定されたアーキテクチャ特性を考慮し、各コンポーネントがそれらを満たせるか、あるいは特性を満たすためにコンポーネント構造の変更が必要かを分析する 。

   **6**

5. **コンポーネントの再構築:** 分析結果に基づき、コンポーネントの分割、統合、境界の調整を行う。

このプロセスは一度で完了するものではなく、フィードバックを得ながら繰り返し洗練させていくことが重要である。

### **アーキテクトと開発者の役割**

コンポーネント定義において、アーキテクトは主に高レベルな分割（アーキテクチャパーティショニング）に責任を持つ。例えば、システム全体を技術的な関心事で分割するレイヤードアーキテクチャを採用するか、ドメインで分割するモジュラーモノリスを採用するかといった最上位の分割方針は、アーキテクトが初期に判断すべき重要な決定の一つである。一方、開発者は、定義されたコンポーネント内部の設計や実装により深く関与する。

### **コンポーネントの粒度**

コンポーネントの「粒度」、つまりサイズをどの程度にするかは重要な設計判断である **6**。粒度が大きすぎると、凝集度が低下し、変更や再利用が困難になる。逆に小さすぎると、コンポーネント間の連携が複雑になり、管理オーバーヘッドが増大する。適切な粒度を見つけることは、最初から完璧に行うのは難しく、反復的なプロセスの中で調整していく必要がある。

### **コンポーネント発見技法**

コンポーネントを発見するためのアプローチとして、単にデータベースのテーブルやエンティティごとにCRUD操作を提供するコンポーネントを作成するようなナイーブな方法（「エンティティの罠」アンチパターン）は避けるべきだと警告されている **17**。これは真のアーキテクチャとは言えず、単なるORMのラッパーに過ぎない可能性がある。より堅牢なアプローチは、システムの役割、責務、そして要求されるアーキテクチャ特性に基づいてコンポーネントを識別することである。本書では、具体的なケーススタディを通じて、この発見プロセスを例示している **6**。

### **モノリシック vs. 分散**

コンポーネントの粒度や境界を決定する議論は、必然的に、システム全体を単一のデプロイ単位（モノリス）として構築するか、複数の独立したサービス（分散アーキテクチャ、例：マイクロサービス）として構築するかの選択につながる。この決定は、アーキテクチャ量子（独立してデプロイ可能で、高い機能的凝集性を持つコンポーネント）のサイズと密接に関連する。

コンポーネント識別は、単なる機能分解ではなく、要求されるアーキテクチャ特性（第4-7章）とモジュール性の原則（第3章）に深く影響される戦略的な設計活動として描かれている。適切なコンポーネントは、システムが「何を」するかだけでなく、「どのように」振る舞う必要があるかを分析することから生まれる。識別フローに特性分析が含まれ、それがコンポーネント再構築につながる可能性があることは、非機能要件がコンポーネント境界を積極的に形成することを示している。「エンティティの罠」は、振る舞いや品質属性を無視した単純なデータ中心の分解に対する警告である。反復的な洗練の強調は、アーキテクチャ設計における不確実性を認め、厳格な事前設計よりも適応的なアプローチを推奨している。

# 関連情報
## モデル・理論
> [!NOTE]
> このカテゴリの理解を助けるためのモデルや理論、抑えるべき原則と問題に対する解決法（メソッド）を記述します。


# サブコンテキスト

> [!NOTE]
> より詳細な事象に対するサブカテゴリを記述します。

[[アーキテクチャスタイル]]
[[ソフトウェア品質特性]]
[[テクニックとソフトスキル]]